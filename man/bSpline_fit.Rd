% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bSpline_fit.R
\name{bSpline_fit}
\alias{bSpline_fit}
\title{One Dimensional Curve Fitting with B-splines}
\usage{
bSpline_fit(
  x,
  y,
  df,
  degree = 3,
  internal_knots = numeric(),
  boundary_knots = numeric()
)
}
\arguments{
\item{x}{A numeric vector representing the predictor.}

\item{y}{A numeric vector representing the response variable.}

\item{df}{An integer representing the degrees of freedom of the spline bases
(including the intercept term).}

\item{degree}{A non-negative integer representing the degree of the
piecewise polynomial.}

\item{internal_knots}{An optional numeric vector for internal knots.}

\item{boundary_knots}{An optional numeric vector (of length two) for
boundary knots.  By default, they are the range of the non-\code{NA}
data.}
}
\value{
A list with named elements:
\itemize{
\item \code{coefficients}: estimated coefficients.
\item \code{fitted.values}: fitted y values.
\item \code{residuals}: residuals.
\item \code{derivatives}: estimated derivatives.
}
}
\description{
Fits one dimensional curve with B-splines and returns fitted values and
residuals.
}
\examples{
library(example.pkg.Rcpp.splines2)

## an example curve
foo <- function(x) {
    (1 - x + 2 * x ^ 2) * exp(- 0.2 * x ^ 2)
}
## generate some random samples
set.seed(123)
n <- 200
x <- runif(n, - 4, 4)
y <- foo(x) + rnorm(n, sd = 0.5)

## 1. use the written Rcpp function
res1 <- bSpline_fit(x, y, df = 6)

## 2. equivalent R code
bs_mat <- splines::bs(x, df = 6, intercept = TRUE)
res2 <- lm.fit(bs_mat, y)

all.equal(res1$coefficients, res2$coefficients, check.attributes = FALSE)
all.equal(res1$fitted.values, res2$fitted.values, check.attributes = FALSE)

if (requireNamespace("microbenchmark", quietly = TRUE)) {
    library(microbenchmark)
    microbenchmark(
        "Rcpp" = bSpline_fit(x, y, df = 6),
        "base R" = lm.fit(splines::bs(x, df = 6, intercept = TRUE), y)
    )
}
}
